<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Memory Match</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&family=Fredoka+One&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #111827; color: #F9FAFB; }
        h1, .card-face { font-family: 'Fredoka One', cursive; }
        .font-black-ops { font-family: 'Inter', sans-serif; font-weight: 900; }
        .btn-primary {
            @apply px-6 py-3 font-semibold text-white bg-sky-500 rounded-lg shadow-md hover:bg-sky-600 focus:outline-none focus:ring-2 focus:ring-sky-400 focus:ring-opacity-75 transition-all duration-300 transform hover:scale-105;
        }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        /* Memory Game Specific Styles */
        .game-board { perspective: 1000px; }
        .card { position: relative; transition: transform 0.6s; transform-style: preserve-3d; cursor: pointer; }
        .card.is-flipped { transform: rotateY(180deg); }
        .card-face {
            position: absolute; width: 100%; height: 100%;
            backface-visibility: hidden; display: flex;
            align-items: center; justify-content: center; border-radius: 0.5rem;
        }
        .card-front { background-color: #4b5563; } /* bg-gray-600 */
        .card-back { background-color: #3b82f6; transform: rotateY(180deg); font-size: 2.5rem; }
        .card.matched .card-back { background-color: #16a34a; }
        .turn-indicator { border: 2px solid #facc15; } /* yellow-400 */

        /* Chat Box Styles */
        #chat-messages { height: 150px; }
        #chat-messages div:nth-child(odd) { background-color: #374151; } /* bg-gray-700 */
    </style>
</head>
<body class="bg-gray-900 text-gray-50 flex flex-col min-h-screen">

    <!-- Header -->
    <header class="bg-gray-900/80 backdrop-blur-sm sticky top-0 z-50 border-b border-gray-700">
        <nav class="w-full max-w-7xl mx-auto px-4 lg:px-8">
            <div class="flex items-center justify-between h-16">
                <a href="index.html" class="text-3xl font-black-ops text-white">FALCONIX<span class="text-sky-400">GAMING</span></a>
                <div id="auth-container" class="flex items-center">
                      <div id="user-info-header" class="hidden items-center space-x-4">
                          <span id="user-display-name" class="text-white font-semibold"></span>
                      </div>
                </div>
            </div>
        </nav>
    </header>

    <!-- Main Content -->
    <main class="flex items-center justify-center flex-grow w-full px-4">
        <div class="bg-gray-800 p-6 sm:p-8 rounded-2xl shadow-2xl w-full max-w-2xl my-8 border border-gray-700">

            <!-- Loading View -->
            <div id="loading-view" class="text-center">
                <h1 class="text-4xl font-bold text-gray-100 mb-4">Checking Login Status...</h1>
                <p class="text-gray-400">Please wait.</p>
            </div>

            <!-- Auth View -->
            <div id="auth-view" class="text-center hidden">
                <h1 class="text-4xl font-bold text-gray-100 mb-4">Welcome!</h1>
                <p class="text-gray-400 mb-6">Please log in on the main page to play multiplayer.</p>
                <a href="index.html?login=true" class="btn-primary w-full inline-block">Go to Login</a>
            </div>

            <!-- Lobby View -->
            <div id="lobby-view" class="hidden">
                <h1 class="text-4xl text-center font-bold text-gray-100 mb-6">Multiplayer Memory Match</h1>
                <div class="space-y-4">
                    <button id="create-game-btn" class="w-full bg-green-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-green-700">Create New Game</button>
                    <div class="relative flex py-2 items-center"><div class="flex-grow border-t border-gray-600"></div><span class="flex-shrink mx-4 text-gray-400">OR</span><div class="flex-grow border-t border-gray-600"></div></div>
                    <input type="text" id="game-id-input" placeholder="Enter Game ID to Join" class="w-full p-3 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-sky-400">
                    <button id="join-game-btn" class="w-full bg-blue-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-blue-700">Join Game</button>
                </div>
                 <div class="text-center mt-6 text-xs text-gray-500"><p>Your User ID: <span id="user-id-display" class="font-mono"></span></p></div>
            </div>

            <!-- Game View -->
            <div id="game-view" class="hidden">
                <!-- ***MODIFIED: Added flex container and Share Button*** -->
                <div class="text-center mb-4 flex justify-center items-center gap-4">
                    <p class="text-sm text-gray-400">Game ID: <span id="game-id-display" class="font-mono cursor-pointer" title="Click to copy"></span></p>
                    <button id="share-game-btn" class="bg-indigo-500 text-white text-xs font-bold py-1 px-3 rounded-lg hover:bg-indigo-600 transition-all hidden">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 inline-block mr-1" viewBox="0 0 20 20" fill="currentColor"><path d="M15 8a3 3 0 10-2.977-2.63l-4.94 2.47a3 3 0 100 4.319l4.94 2.47a3 3 0 10.895-1.789l-4.94-2.47a3.027 3.027 0 000-.74l4.94-2.47C13.456 7.68 14.19 8 15 8z" /></svg>
                        Share
                    </button>
                </div>
                <!-- Scoreboard -->
                <div id="scoreboard" class="flex justify-around text-center mb-4">
                    <div id="player1-score-box" class="p-2 rounded-lg"><p class="text-lg font-bold text-red-500">Player 1 (<span id="player1-name"></span>)</p><p id="score-p1" class="text-3xl font-bold text-gray-100">0</p></div>
                    <div id="player2-score-box" class="p-2 rounded-lg"><p class="text-lg font-bold text-blue-400">Player 2 (<span id="player2-name"></span>)</p><p id="score-p2" class="text-3xl font-bold text-gray-100">0</p></div>
                </div>
                <!-- Status Display -->
                <div id="status" class="text-center text-xl font-semibold text-gray-400 mb-4 h-8 flex items-center justify-center"></div>
                <!-- Game Board -->
                <div id="game-board" class="grid grid-cols-4 gap-4 mb-6"></div>
                 <!-- Chat Box -->
                <div id="chat-box" class="mb-4">
                    <div id="chat-messages" class="bg-gray-900 rounded-lg p-2 overflow-y-auto border border-gray-600"></div>
                    <div class="flex mt-2">
                        <input type="text" id="chat-input" placeholder="Type a message..." class="flex-grow p-2 bg-gray-700 border border-gray-600 rounded-l-lg text-white focus:outline-none focus:ring-2 focus:ring-sky-400">
                        <button id="send-chat-btn" class="bg-sky-500 text-white font-bold py-2 px-4 rounded-r-lg hover:bg-sky-600">Send</button>
                    </div>
                </div>
                <div class="space-y-2">
                    <button id="rematch-btn" class="w-full bg-yellow-500 text-white font-bold py-3 px-4 rounded-lg hover:bg-yellow-600 hidden">Request Rematch</button>
                    <button id="leave-game-btn" class="w-full bg-red-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-red-700">Leave Game</button>
                </div>
            </div>
             <!-- Message Modal -->
            <div id="message-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"><div class="bg-gray-800 p-6 rounded-lg shadow-xl text-center"><p id="message-text" class="text-lg mb-4"></p><button id="close-modal-btn" class="btn-primary">Close</button></div></div>
        </div>
    </main>

    <script type="module">
        // --- FIREBASE IMPORTS ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, updateDoc, collection, addDoc, serverTimestamp, query, orderBy } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

        // --- YOUR FALCONIXGAMING FIREBASE CONFIGURATION ---
        const firebaseConfig = {
            apiKey: "AIzaSyD02ui4dhTuGLz-Ff1af36ERdqqsn4iIeU",
            authDomain: "falconixgaming-46210.firebaseapp.com",
            projectId: "falconixgaming-46210",
            storageBucket: "falconixgaming-46210.appspot.com",
            messagingSenderId: "1096905282147",
            appId: "1:1096905282147:web:e2faa9105d31c6ec009e56",
            measurementId: "G-VJ6YC0GXK5"
        };
        
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // --- DOM ELEMENTS ---
        const loadingView = document.getElementById('loading-view');
        const authView = document.getElementById('auth-view'), lobbyView = document.getElementById('lobby-view'), gameView = document.getElementById('game-view');
        const userInfoHeader = document.getElementById('user-info-header'), userDisplayName = document.getElementById('user-display-name');
        const createGameBtn = document.getElementById('create-game-btn'), joinGameBtn = document.getElementById('join-game-btn');
        const leaveGameBtn = document.getElementById('leave-game-btn'), rematchBtn = document.getElementById('rematch-btn');
        const gameIdInput = document.getElementById('game-id-input'), userIdDisplay = document.getElementById('user-id-display');
        const gameIdDisplay = document.getElementById('game-id-display'), statusDisplay = document.getElementById('status');
        const player1ScoreBox = document.getElementById('player1-score-box'), player2ScoreBox = document.getElementById('player2-score-box');
        const scoreP1Display = document.getElementById('score-p1'), scoreP2Display = document.getElementById('score-p2');
        const player1Name = document.getElementById('player1-name'), player2Name = document.getElementById('player2-name');
        const gameBoard = document.getElementById('game-board');
        const chatMessages = document.getElementById('chat-messages'), chatInput = document.getElementById('chat-input'), sendChatBtn = document.getElementById('send-chat-btn');
        const messageModal = document.getElementById('message-modal'), messageText = document.getElementById('message-text'), closeModalBtn = document.getElementById('close-modal-btn');
        // ***NEW: Get share button element***
        const shareGameBtn = document.getElementById('share-game-btn');


        // --- GAME STATE & CONSTANTS ---
        let currentUser = null, currentGameId = null, playerRole = null;
        let unsubscribeGame = null, unsubscribeChat = null;
        const cardSymbols = ['🚀', '�', '⭐', '🎉', '💎', '💯', '💡', '🏆'];

        // ***NEW: Handle game ID from URL on page load***
        document.addEventListener('DOMContentLoaded', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const gameIdFromUrl = urlParams.get('gameId');
            if (gameIdFromUrl) {
                gameIdInput.value = gameIdFromUrl;
                showMessage(`Ready to join game ${gameIdFromUrl}. Click "Join Game" when you're logged in!`);
            }
        });

        // --- AUTHENTICATION FLOW ---
        onAuthStateChanged(auth, user => {
            currentUser = user;
            loadingView.classList.add('hidden'); 
            if (user) {
                userDisplayName.textContent = user.displayName;
                userIdDisplay.textContent = user.uid;
                userInfoHeader.classList.remove('hidden');
                authView.classList.add('hidden');
                if (gameView.classList.contains('hidden')) { 
                    lobbyView.classList.remove('hidden');
                }
            } else {
                userDisplayName.textContent = '';
                userInfoHeader.classList.add('hidden');
                authView.classList.remove('hidden');
                lobbyView.classList.add('hidden');
                if (!gameView.classList.contains('hidden')) {
                    leaveGameBtn.click();
                }
            }
        });
        
        // --- LOBBY LOGIC ---
        createGameBtn.onclick = async () => {
            const gameId = crypto.randomUUID().split('-')[0];
            const gameRef = doc(db, "mp-memory-match", gameId);
            
            const fullDeck = [...cardSymbols, ...cardSymbols];
            shuffleArray(fullDeck);
            const gameCards = fullDeck.map(symbol => ({ symbol, isFlipped: false, isMatched: false }));

            await setDoc(gameRef, {
                cards: gameCards,
                players: { [currentUser.uid]: { role: 'P1', name: currentUser.displayName } },
                playerIds: [currentUser.uid],
                currentPlayerId: currentUser.uid,
                scores: { P1: 0, P2: 0 },
                status: 'waiting',
                flippedIndices: [],
                lockBoard: false,
                rematch: {}
            });
            switchToGameView(gameId, 'P1');
        };

        joinGameBtn.onclick = async () => {
            const gameId = gameIdInput.value.trim();
            if (!gameId) return showMessage("Please enter a Game ID.");
            const gameRef = doc(db, "mp-memory-match", gameId);
            const gameSnap = await getDoc(gameRef);

            if (gameSnap.exists()) {
                const gameData = gameSnap.data();
                if (gameData.playerIds.length === 1 && !gameData.playerIds.includes(currentUser.uid)) {
                    await updateDoc(gameRef, {
                        [`players.${currentUser.uid}`]: { role: 'P2', name: currentUser.displayName },
                        playerIds: [...gameData.playerIds, currentUser.uid],
                        status: 'active'
                    });
                    switchToGameView(gameId, 'P2');
                } else if (gameData.playerIds.includes(currentUser.uid)) {
                    switchToGameView(gameId, gameData.players[currentUser.uid].role);
                } else {
                    showMessage("This game is full.");
                }
            } else {
                showMessage("Game not found.");
            }
        };
        
        leaveGameBtn.onclick = async () => {
            if (currentGameId) {
                const gameRef = doc(db, "mp-memory-match", currentGameId);
                await updateDoc(gameRef, { status: 'abandoned' }).catch(err => {});
            }
            if (unsubscribeGame) unsubscribeGame();
            if (unsubscribeChat) unsubscribeChat();
            switchToLobbyView();
        };

        rematchBtn.onclick = async () => {
            const gameRef = doc(db, "mp-memory-match", currentGameId);
            const gameSnap = await getDoc(gameRef);
            const gameData = gameSnap.data();
            
            const newRematchState = { ...gameData.rematch, [currentUser.uid]: true };
            
            if (Object.keys(newRematchState).length === 2) {
                const fullDeck = [...cardSymbols, ...cardSymbols];
                shuffleArray(fullDeck);
                const newCards = fullDeck.map(symbol => ({ symbol, isFlipped: false, isMatched: false }));

                await updateDoc(gameRef, {
                    cards: newCards,
                    status: 'active',
                    flippedIndices: [],
                    lockBoard: false,
                    rematch: {},
                    currentPlayerId: gameData.playerIds.find(id => id !== gameData.currentPlayerId) || gameData.playerIds[0] // Alternate starter
                });
            } else {
                await updateDoc(gameRef, { rematch: newRematchState });
            }
        };

        // --- GAME LOGIC ---
        function switchToGameView(gameId, role) {
            currentGameId = gameId; playerRole = role;
            gameIdDisplay.textContent = gameId;
            lobbyView.classList.add('hidden');
            gameView.classList.remove('hidden');
            // ***NEW: Show the share button***
            shareGameBtn.classList.remove('hidden');

            const gameRef = doc(db, "mp-memory-match", gameId);
            unsubscribeGame = onSnapshot(gameRef, (doc) => {
                const gameData = doc.data();
                if (gameData) renderGameState(gameData);
                else { showMessage("The game session has ended."); leaveGameBtn.click(); }
            });

            const chatRef = collection(db, "mp-memory-match", gameId, "messages");
            const q = query(chatRef, orderBy("timestamp"));
            unsubscribeChat = onSnapshot(q, (snapshot) => {
                chatMessages.innerHTML = '';
                snapshot.forEach(doc => {
                    const msg = doc.data();
                    chatMessages.innerHTML += `<div class="p-2 rounded-lg">${msg.senderName} (${msg.senderRole}): ${msg.text}</div>`;
                });
                chatMessages.scrollTop = chatMessages.scrollHeight;
            });
        }
        
        function switchToLobbyView() {
            gameView.classList.add('hidden');
            if(currentUser) lobbyView.classList.remove('hidden');
            else authView.classList.remove('hidden');
            gameIdInput.value = '';
            // ***NEW: Hide the share button***
            shareGameBtn.classList.add('hidden');
        }

        function renderGameState(gameData) {
            if (handleAbandoned(gameData)) return;
            
            gameBoard.innerHTML = '';
            gameData.cards.forEach((card, index) => {
                const cardEl = document.createElement('div');
                cardEl.classList.add('card', 'h-24');
                if (card.isFlipped) cardEl.classList.add('is-flipped');
                if (card.isMatched) cardEl.classList.add('matched');
                cardEl.dataset.index = index;
                cardEl.innerHTML = `<div class="card-face card-front"></div><div class="card-face card-back">${card.symbol}</div>`;
                cardEl.onclick = handleCardClick;
                gameBoard.appendChild(cardEl);
            });

            const player1Id = gameData.playerIds[0];
            const player2Id = gameData.playerIds[1];
            player1Name.textContent = gameData.players[player1Id]?.name.split(' ')[0] || 'Waiting...';
            player2Name.textContent = player2Id ? gameData.players[player2Id]?.name.split(' ')[0] : 'Waiting...';

            scoreP1Display.textContent = gameData.scores.P1;
            scoreP2Display.textContent = gameData.scores.P2 || 0;
            player1ScoreBox.classList.toggle('turn-indicator', gameData.currentPlayerId === player1Id);
            player2ScoreBox.classList.toggle('turn-indicator', gameData.currentPlayerId === player2Id);
            
            rematchBtn.classList.add('hidden');
            if (gameData.status === 'finished') {
                const winnerId = gameData.scores.P1 > gameData.scores.P2 ? player1Id : (gameData.scores.P2 > gameData.scores.P1 ? player2Id : null);
                statusDisplay.textContent = winnerId ? `${gameData.players[winnerId].name} wins!` : "It's a draw!";
                rematchBtn.classList.remove('hidden');
                if (gameData.rematch[currentUser.uid]) {
                    rematchBtn.textContent = 'Waiting for opponent...';
                    rematchBtn.disabled = true;
                } else {
                    rematchBtn.textContent = 'Request Rematch';
                    rematchBtn.disabled = false;
                }
            } else if (gameData.status === 'waiting') {
                statusDisplay.textContent = 'Waiting for Player 2...';
            } else {
                statusDisplay.textContent = gameData.currentPlayerId === currentUser.uid ? "Your turn" : "Opponent's turn";
            }
        }

        async function handleCardClick(e) {
            const clickedIndex = parseInt(e.currentTarget.dataset.index);
            const gameRef = doc(db, "mp-memory-match", currentGameId);
            const gameSnap = await getDoc(gameRef);
            const gameData = gameSnap.data();

            if (gameData.lockBoard || gameData.currentPlayerId !== currentUser.uid || gameData.cards[clickedIndex].isFlipped) return;

            let newCards = [...gameData.cards];
            newCards[clickedIndex].isFlipped = true;
            let newFlippedIndices = [...gameData.flippedIndices, clickedIndex];
            
            await updateDoc(gameRef, { cards: newCards, flippedIndices: newFlippedIndices, lockBoard: true });

            if (newFlippedIndices.length === 2) {
                setTimeout(async () => {
                    const latestSnap = await getDoc(gameRef);
                    const latestData = latestSnap.data();
                    const [index1, index2] = newFlippedIndices;
                    newCards = [...latestData.cards]; 
                    const card1 = newCards[index1];
                    const card2 = newCards[index2];

                    let updates = {};
                    if (card1.symbol === card2.symbol) {
                        card1.isMatched = true;
                        card2.isMatched = true;
                        updates[`scores.${playerRole}`] = latestData.scores[playerRole] + 1;
                        updates.lockBoard = false;
                    } else {
                        card1.isFlipped = false;
                        card2.isFlipped = false;
                        const opponentId = latestData.playerIds.find(id => id !== currentUser.uid);
                        updates.currentPlayerId = opponentId;
                        updates.lockBoard = false;
                    }
                    
                    updates.cards = newCards;
                    updates.flippedIndices = [];
                    if (newCards.every(c => c.isMatched)) updates.status = 'finished';

                    await updateDoc(gameRef, updates);
                }, 1000);
            } else {
                await updateDoc(gameRef, { lockBoard: false });
            }
        }

        function handleAbandoned(gameData) {
            if (gameData.status === 'abandoned') {
                showMessage("Your opponent has left the game.");
                setTimeout(() => leaveGameBtn.click(), 3000);
                return true;
            }
            return false;
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        sendChatBtn.onclick = async () => {
            const text = chatInput.value.trim();
            if (text && currentUser) {
                const chatRef = collection(db, "mp-memory-match", currentGameId, "messages");
                await addDoc(chatRef, { text, senderId: currentUser.uid, senderName: currentUser.displayName, senderRole: playerRole, timestamp: serverTimestamp() });
                chatInput.value = '';
            }
        };
        chatInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') sendChatBtn.click(); });
        
        function showMessage(msg) { messageText.textContent = msg; messageModal.classList.remove('hidden'); }
        closeModalBtn.onclick = () => messageModal.classList.add('hidden');
        gameIdDisplay.onclick = () => navigator.clipboard.writeText(currentGameId).then(() => showMessage("Game ID copied!"));

        // ***NEW: Share button functionality***
        shareGameBtn.onclick = async () => {
            if (!currentGameId) return;

            const shareUrl = `${window.location.origin}${window.location.pathname}?gameId=${currentGameId}`;
            
            const shareText = `I challenge you to a Memory Match game! 🧠✨\n\nJoin my game with this code: ${currentGameId}\n\nOr click the link to join directly:`;

            if (navigator.share) {
                try {
                    await navigator.share({
                        title: 'FalconixGaming Memory Match Challenge',
                        text: shareText,
                        url: shareUrl,
                    });
                } catch (error) {
                    console.error('Error sharing:', error);
                    showMessage('Sharing was cancelled or failed.');
                }
            } else {
                navigator.clipboard.writeText(shareUrl).then(() => {
                     showMessage('Share feature not supported on your browser. Game link copied to clipboard!');
                });
            }
        };

    </script>
</body>
</html>
