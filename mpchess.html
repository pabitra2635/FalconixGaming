<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Online Chess Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: manipulation;
        }
        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 90vw;
            aspect-ratio: 1 / 1;
            max-width: 700px; 
            border: 2px solid #374151;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .square {
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
        }
        .light {
            background-color: #F3F4F6;
        }
        .dark {
            background-color: #60A5FA;
        }
        .selected {
            background-color: #FBBF24 !important;
        }
        .valid-move {
            background-color: #A7F3D0;
            cursor: pointer;
            position: relative;
        }
        .valid-move::after {
            content: '';
            position: absolute;
            width: 40%;
            height: 40%;
            border-radius: 50%;
            background-color: rgba(22, 163, 74, 0.5);
        }
        .in-check {
            background-color: #F87171 !important;
        }
        .piece {
            cursor: grab;
            font-size: var(--piece-font-size, 32px);
            line-height: 1;
        }
        .piece.grabbing {
            cursor: grabbing;
        }
        .captured-pieces-container {
            min-height: 50px;
            background-color: #e5e7eb;
            border-radius: 0.5rem;
            padding: 8px;
            margin-top: 1rem;
            width: 100%;
            max-width: 700px;
        }
        .captured-pieces-container h3 {
            font-weight: 600;
            margin-bottom: 4px;
            color: #4b5563;
        }
        .captured-pieces {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            font-size: 24px;
        }
        .game-over {
            background-color: #10B981 !important;
            transition: background-color 0.5s ease;
        }
        .game-over p {
            color: white !important;
            font-weight: 700 !important;
        }
    </style>
</head>
<body class="bg-gray-200 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-4xl mx-auto flex flex-col items-center">
        <h1 class="text-3xl md:text-5xl font-bold text-center text-gray-800 mb-4">Chess Game</h1>
        
        <div id="captured-by-black-container" class="captured-pieces-container">
            <h3>Captured by Black:</h3>
            <div id="captured-by-black" class="captured-pieces"></div>
        </div>

        <div id="status-container" class="text-center my-4 p-3 rounded-lg bg-white shadow-md w-full max-w-sm transition-colors duration-300">
            <p id="status" class="text-lg md:text-xl font-semibold text-gray-700">White's Turn</p>
        </div>

        <div class="flex justify-center">
            <div id="board" class="board"></div>
        </div>

        <div id="captured-by-white-container" class="captured-pieces-container">
            <h3>Captured by White:</h3>
            <div id="captured-by-white" class="captured-pieces"></div>
        </div>

        <div class="text-center mt-4">
            <button id="resetButton" class="px-6 py-3 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75 transition-transform transform hover:scale-105">
                New Game
            </button>
        </div>
    </div>

    <!-- Promotion Modal -->
    <div id="promotion-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center hidden">
        <div class="bg-white p-6 rounded-lg shadow-xl text-center">
            <h3 class="text-2xl font-bold mb-4">Promote Pawn to:</h3>
            <div id="promotion-choices" class="flex justify-center space-x-4"></div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const boardElement = document.getElementById('board');
        const statusContainer = document.getElementById('status-container');
        const statusElement = document.getElementById('status');
        const resetButton = document.getElementById('resetButton');
        const promotionModal = document.getElementById('promotion-modal');
        const promotionChoices = document.getElementById('promotion-choices');
        const capturedByWhiteElement = document.getElementById('captured-by-white');
        const capturedByBlackElement = document.getElementById('captured-by-black');

        // --- Game State ---
        let boardState;
        let currentPlayer;
        let selectedPiece = null;
        let validMoves = [];
        let gameEnded = false;
        let pawnPromotionData = null;
        let capturedByWhite = [];
        let capturedByBlack = [];

        // --- Piece Representations (Unicode) ---
        const pieces = {
            'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',
            'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟'
        };

        // --- Game Initialization ---
        function initializeGame() {
            boardState = [
                ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
                ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
                ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
            ];
            currentPlayer = 'white';
            selectedPiece = null;
            validMoves = [];
            gameEnded = false;
            capturedByWhite = [];
            capturedByBlack = [];
            
            // --- FIX: Reset status container style before setting text ---
            statusContainer.classList.remove('game-over');
            updateStatus("White's Turn to Move");
            
            renderBoard();
            renderCapturedPieces();
        }

        function adjustPieceSizes() {
            const square = boardElement.querySelector('.square');
            if (square) {
                const squareWidth = square.offsetWidth;
                const newSize = squareWidth * 0.7;
                boardElement.style.setProperty('--piece-font-size', `${newSize}px`);
            }
        }
        
        function renderCapturedPieces() {
            capturedByWhiteElement.innerHTML = '';
            capturedByBlackElement.innerHTML = '';
            
            capturedByWhite.sort().forEach(piece => {
                const pieceEl = document.createElement('span');
                pieceEl.textContent = pieces[piece];
                capturedByWhiteElement.appendChild(pieceEl);
            });
            
            capturedByBlack.sort().forEach(piece => {
                const pieceEl = document.createElement('span');
                pieceEl.textContent = pieces[piece];
                capturedByBlackElement.appendChild(pieceEl);
            });
        }

        function renderBoard() {
            boardElement.innerHTML = '';
            removeHighlights();

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.dataset.row = row;
                    square.dataset.col = col;
                    square.classList.add('square');
                    square.classList.add((row + col) % 2 === 0 ? 'light' : 'dark');

                    const piece = boardState[row][col];
                    if (piece) {
                        const pieceElement = document.createElement('span');
                        pieceElement.classList.add('piece');
                        pieceElement.textContent = pieces[piece];
                        pieceElement.style.color = isUpperCase(piece) ? '#374151' : '#111827';
                        square.appendChild(pieceElement);
                    }

                    square.addEventListener('click', () => onSquareClick(row, col));
                    boardElement.appendChild(square);
                }
            }
            
            adjustPieceSizes();
            highlightCheck();
        }

        function removeHighlights() {
            document.querySelectorAll('.selected, .valid-move').forEach(el => {
                el.classList.remove('selected', 'valid-move');
            });
        }
        
        function highlightCheck() {
            document.querySelectorAll('.in-check').forEach(el => el.classList.remove('in-check'));
            if (gameEnded) return;
            const kingPosition = findKing(currentPlayer);
            if (kingPosition && isKingInCheck(currentPlayer, boardState)) {
                 const kingSquare = document.querySelector(`[data-row='${kingPosition.row}'][data-col='${kingPosition.col}']`);
                 if(kingSquare) kingSquare.classList.add('in-check');
            }
        }

        function onSquareClick(row, col) {
            if (gameEnded) return;

            if (validMoves.some(move => move.row === row && move.col === col)) {
                movePiece(selectedPiece.row, selectedPiece.col, row, col);
                return;
            }

            removeHighlights();
            selectedPiece = null;
            validMoves = [];

            const piece = boardState[row][col];
            if (piece && getPieceColor(piece) === currentPlayer) {
                selectedPiece = { row, col, piece };
                const square = document.querySelector(`[data-row='${row}'][data-col='${col}']`);
                square.classList.add('selected');

                validMoves = getValidMovesForPiece(row, col, piece, boardState);
                validMoves.forEach(move => {
                    const moveSquare = document.querySelector(`[data-row='${move.row}'][data-col='${move.col}']`);
                    if (moveSquare) moveSquare.classList.add('valid-move');
                });
            }
        }

        // --- Game Logic ---
        function movePiece(fromRow, fromCol, toRow, toCol) {
            const capturedPiece = boardState[toRow][toCol];
            if (capturedPiece) {
                if (currentPlayer === 'white') {
                    capturedByWhite.push(capturedPiece);
                } else {
                    capturedByBlack.push(capturedPiece);
                }
                // --- FIX: Render captured pieces immediately after capture ---
                renderCapturedPieces();
            }
            
            const piece = boardState[fromRow][fromCol];
            if ((piece === 'P' && toRow === 0) || (piece === 'p' && toRow === 7)) {
                pawnPromotionData = { fromRow, fromCol, toRow, toCol };
                showPromotionDialog();
                return;
            }

            boardState[toRow][toCol] = boardState[fromRow][fromCol];
            boardState[fromRow][fromCol] = null;
            
            selectedPiece = null;
            validMoves = [];
            
            switchPlayer();
            renderBoard();
            checkGameState();
        }

        function switchPlayer() {
            currentPlayer = (currentPlayer === 'white') ? 'black' : 'white';
        }

        function updateStatus(message, isGameOver = false) {
            statusElement.textContent = message;
            if (isGameOver) {
                statusContainer.classList.add('game-over');
            } else {
                statusContainer.classList.remove('game-over');
            }
        }

        function checkGameState() {
            const kingInCheck = isKingInCheck(currentPlayer, boardState);
            const hasLegalMoves = playerHasLegalMoves(currentPlayer, boardState);

            if (kingInCheck) {
                if (!hasLegalMoves) {
                    gameEnded = true;
                    const winner = currentPlayer === 'white' ? 'Black' : 'White';
                    updateStatus(`CHECKMATE! ${winner} wins the game.`, true);
                } else {
                    updateStatus(`${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)} is in CHECK!`);
                }
            } else if (!hasLegalMoves) {
                gameEnded = true;
                updateStatus("STALEMATE! The game is a draw.", true);
            } else {
                updateStatus(`${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)}'s Turn to Move`);
            }
        }

        function getValidMovesForPiece(row, col, piece, currentBoard) {
            let moves = [];
            const color = getPieceColor(piece);

            switch (piece.toUpperCase()) {
                case 'P': moves = getPawnMoves(row, col, color, currentBoard); break;
                case 'R': moves = getRookMoves(row, col, color, currentBoard); break;
                case 'N': moves = getKnightMoves(row, col, color, currentBoard); break;
                case 'B': moves = getBishopMoves(row, col, color, currentBoard); break;
                case 'Q': moves = getQueenMoves(row, col, color, currentBoard); break;
                case 'K': moves = getKingMoves(row, col, color, currentBoard); break;
            }
            
            return moves.filter(move => {
                const tempBoard = JSON.parse(JSON.stringify(currentBoard));
                tempBoard[move.row][move.col] = tempBoard[row][col];
                tempBoard[row][col] = null;
                return !isKingInCheck(color, tempBoard);
            });
        }
        
        function playerHasLegalMoves(playerColor, board) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (piece && getPieceColor(piece) === playerColor) {
                        if (getValidMovesForPiece(r, c, piece, board).length > 0) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // --- Piece-Specific Move Logic (abbreviated for brevity) ---
        function getPawnMoves(r,c,color,b) { const m=[],d=color==='white'?-1:1,s=color==='white'?6:1;if(isValid(r+d,c)&&!b[r+d][c]){m.push({row:r+d,col:c});if(r===s&&!b[r+2*d][c]){m.push({row:r+2*d,col:c})}}[-1,1].forEach(dc=>{if(isValid(r+d,c+dc)){const t=b[r+d][c+dc];if(t&&getPieceColor(t)!==color){m.push({row:r+d,col:c+dc})}}});return m; }
        function getRookMoves(r,c,color,b) { return getSlidingMoves(r,c,color,b,[[-1,0],[1,0],[0,-1],[0,1]]); }
        function getBishopMoves(r,c,color,b) { return getSlidingMoves(r,c,color,b,[[-1,-1],[-1,1],[1,-1],[1,1]]); }
        function getQueenMoves(r,c,color,b) { return getSlidingMoves(r,c,color,b,[[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[-1,1],[1,-1],[1,1]]); }
        function getSlidingMoves(r,c,color,b,dirs) { const m=[];dirs.forEach(([dr,dc])=>{for(let i=1;i<8;i++){const nr=r+i*dr,nc=c+i*dc;if(!isValid(nr,nc))break;const t=b[nr][nc];if(t){if(getPieceColor(t)!==color){m.push({row:nr,col:nc})}break}m.push({row:nr,col:nc})}});return m; }
        function getKnightMoves(r,c,color,b) { const m=[],km=[[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];km.forEach(([dr,dc])=>{const nr=r+dr,nc=c+dc;if(isValid(nr,nc)){const t=b[nr][nc];if(!t||getPieceColor(t)!==color){m.push({row:nr,col:nc})}}});return m; }
        function getKingMoves(r,c,color,b) { const m=[],km=[[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];km.forEach(([dr,dc])=>{const nr=r+dr,nc=c+dc;if(isValid(nr,nc)){const t=b[nr][nc];if(!t||getPieceColor(t)!==color){m.push({row:nr,col:nc})}}});return m; }

        function isKingInCheck(kingColor, board) {
            const kingPos = findKing(kingColor, board);
            if (!kingPos) return false;
            const opponentColor = kingColor === 'white' ? 'black' : 'white';
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (piece && getPieceColor(piece) === opponentColor) {
                        let rawMoves;
                        switch (piece.toUpperCase()) {
                            case 'P': rawMoves = getPawnMoves(r, c, opponentColor, board); break;
                            case 'R': rawMoves = getRookMoves(r, c, opponentColor, board); break;
                            case 'N': rawMoves = getKnightMoves(r, c, opponentColor, board); break;
                            case 'B': rawMoves = getBishopMoves(r, c, opponentColor, board); break;
                            case 'Q': rawMoves = getQueenMoves(r, c, opponentColor, board); break;
                            case 'K': rawMoves = getKingMoves(r, c, opponentColor, board); break;
                            default: rawMoves = [];
                        }
                        if (rawMoves.some(move => move.row === kingPos.row && move.col === kingPos.col)) return true;
                    }
                }
            }
            return false;
        }

        function findKing(color, board) {
            const kingPiece = color === 'white' ? 'K' : 'k';
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (board[r][c] === kingPiece) return { row: r, col: c };
                }
            }
            return null;
        }

        function showPromotionDialog() {
            promotionChoices.innerHTML = '';
            const promotionPieces = currentPlayer === 'white' ? ['Q', 'R', 'B', 'N'] : ['q', 'r', 'b', 'n'];
            promotionPieces.forEach(p => {
                const button = document.createElement('button');
                button.textContent = pieces[p];
                button.classList.add('text-5xl', 'p-2', 'hover:bg-gray-200', 'rounded-md');
                button.onclick = () => choosePromotion(p);
                promotionChoices.appendChild(button);
            });
            promotionModal.classList.remove('hidden');
        }

        // --- FIX: Correctly handle captures during promotion ---
        function choosePromotion(promotedPiece) {
            if (!pawnPromotionData) return;
            const { fromRow, fromCol, toRow, toCol } = pawnPromotionData;
            
            // The piece at the destination was already captured in movePiece,
            // so we only need to handle the promotion itself.
            boardState[toRow][toCol] = promotedPiece;
            boardState[fromRow][fromCol] = null;

            pawnPromotionData = null;
            selectedPiece = null;
            validMoves = [];
            promotionModal.classList.add('hidden');
            
            switchPlayer();
            renderBoard();
            checkGameState();
        }

        function isValid(row, col) { return row >= 0 && row < 8 && col >= 0 && col < 8; }
        function getPieceColor(piece) { return isUpperCase(piece) ? 'white' : 'black'; }
        function isUpperCase(char) { return char === char.toUpperCase(); }

        resetButton.addEventListener('click', initializeGame);
        window.addEventListener('resize', renderBoard);

        initializeGame();
    </script>
</body>
</html>
